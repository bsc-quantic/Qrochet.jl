var documenterSearchIndex = {"docs":
[{"location":"ansatz/chain.html#Matrix-Product-States-(MPS)","page":"Chain ansatz","title":"Matrix Product States (MPS)","text":"","category":"section"},{"location":"ansatz/chain.html","page":"Chain ansatz","title":"Chain ansatz","text":"Matrix Product States (MPS) are a Quantum Tensor Network ansatz whose tensors are laid out in a 1D chain. Due to this, these networks are also known as Tensor Trains in other mathematical fields. Depending on the boundary conditions, the chains can be open or closed (i.e. periodic boundary conditions).","category":"page"},{"location":"ansatz/chain.html","page":"Chain ansatz","title":"Chain ansatz","text":"using Makie\nMakie.inline!(true)\nset_theme!(resolution=(800,200))\n\nusing CairoMakie\n\nusing Qrochet\nusing NetworkLayout","category":"page"},{"location":"ansatz/chain.html","page":"Chain ansatz","title":"Chain ansatz","text":"fig = Figure() # hide\n\ntn_open = rand(MatrixProduct{State,Open}, n=10, χ=4) # hide\ntn_periodic = rand(MatrixProduct{State,Periodic}, n=10, χ=4) # hide\n\nplot!(fig[1,1], tn_open, layout=Spring(iterations=1000, C=0.5, seed=100)) # hide\nplot!(fig[1,2], tn_periodic, layout=Spring(iterations=1000, C=0.5, seed=100)) # hide\n\nLabel(fig[1,1, Bottom()], \"Open\") # hide\nLabel(fig[1,2, Bottom()], \"Periodic\") # hide\n\nfig # hide","category":"page"},{"location":"ansatz/chain.html#Matrix-Product-Operators-(MPO)","page":"Chain ansatz","title":"Matrix Product Operators (MPO)","text":"","category":"section"},{"location":"ansatz/chain.html","page":"Chain ansatz","title":"Chain ansatz","text":"Matrix Product Operators (MPO) are the operator version of Matrix Product State (MPS). The major difference between them is that MPOs have 2 indices per site (1 input and 1 output) while MPSs only have 1 index per site (i.e. an output).","category":"page"},{"location":"ansatz/chain.html","page":"Chain ansatz","title":"Chain ansatz","text":"fig = Figure() # hide\n\ntn_open = rand(MatrixProduct{Operator,Open}, n=10, χ=4) # hide\ntn_periodic = rand(MatrixProduct{Operator,Periodic}, n=10, χ=4) # hide\n\nplot!(fig[1,1], tn_open, layout=Spring(iterations=1000, C=0.5, seed=100)) # hide\nplot!(fig[1,2], tn_periodic, layout=Spring(iterations=1000, C=0.5, seed=100)) # hide\n\nLabel(fig[1,1, Bottom()], \"Open\") # hide\nLabel(fig[1,2, Bottom()], \"Periodic\") # hide\n\nfig # hide","category":"page"},{"location":"ansatz/chain.html","page":"Chain ansatz","title":"Chain ansatz","text":"In Tenet, the generic MatrixProduct ansatz implements this topology. Type variables are used to address their functionality (State or Operator) and their boundary conditions (Open or Periodic).","category":"page"},{"location":"ansatz/chain.html","page":"Chain ansatz","title":"Chain ansatz","text":"MatrixProduct\nMatrixProduct(::Any)","category":"page"},{"location":"ansatz/product.html#Product-ansatz","page":"Product ansatz","title":"Product ansatz","text":"","category":"section"},{"location":"quantum.html#Quantum-Tensor-Networks","page":"Quantum","title":"Quantum Tensor Networks","text":"","category":"section"},{"location":"quantum.html","page":"Quantum","title":"Quantum","text":"Quantum\nTenet.TensorNetwork(::Quantum)\nBase.adjoint(::Quantum)\nsites\nnsites","category":"page"},{"location":"quantum.html#Qrochet.Quantum","page":"Quantum","title":"Qrochet.Quantum","text":"Quantum\n\nTensor Network with a notion of \"causality\". This leads to the notion of sites and directionality (input/output).\n\nNotes\n\nIndices are referenced by Sites.\n\n\n\n\n\n","category":"type"},{"location":"quantum.html#Base.adjoint-Tuple{Quantum}","page":"Quantum","title":"Base.adjoint","text":"adjoint(q::Quantum)\n\nReturns the adjoint of a Quantum Tensor Network; i.e. the conjugate Tensor Network with the inputs and outputs swapped.\n\n\n\n\n\n","category":"method"},{"location":"quantum.html#Qrochet.sites","page":"Quantum","title":"Qrochet.sites","text":"sites(q::Quantum)\n\nReturns the sites of a Quantum Tensor Network.\n\n\n\n\n\n","category":"function"},{"location":"quantum.html#Qrochet.nsites","page":"Quantum","title":"Qrochet.nsites","text":"nsites(q::Quantum)\n\nReturns the number of sites of a Quantum Tensor Network.\n\n\n\n\n\n","category":"function"},{"location":"quantum.html#Queries","page":"Quantum","title":"Queries","text":"","category":"section"},{"location":"quantum.html","page":"Quantum","title":"Quantum","text":"Tenet.inds(::Quantum; kwargs...)\nTenet.tensors(::Quantum; kwargs...)","category":"page"},{"location":"quantum.html#Connecting-Quantum-Tensor-Networks","page":"Quantum","title":"Connecting Quantum Tensor Networks","text":"","category":"section"},{"location":"quantum.html","page":"Quantum","title":"Quantum","text":"inputs\noutputs\nlanes\nninputs\nnoutputs\nnlanes","category":"page"},{"location":"quantum.html#Qrochet.inputs","page":"Quantum","title":"Qrochet.inputs","text":"inputs(q::Quantum)\n\nReturns the input sites of a Quantum Tensor Network.\n\n\n\n\n\n","category":"function"},{"location":"quantum.html#Qrochet.outputs","page":"Quantum","title":"Qrochet.outputs","text":"outputs(q::Quantum)\n\nReturns the output sites of a Quantum Tensor Network.\n\n\n\n\n\n","category":"function"},{"location":"quantum.html#Qrochet.ninputs","page":"Quantum","title":"Qrochet.ninputs","text":"ninputs(q::Quantum)\n\nReturns the number of input sites of a Quantum Tensor Network.\n\n\n\n\n\n","category":"function"},{"location":"quantum.html#Qrochet.noutputs","page":"Quantum","title":"Qrochet.noutputs","text":"noutputs(q::Quantum)\n\nReturns the number of output sites of a Quantum Tensor Network.\n\n\n\n\n\n","category":"function"},{"location":"quantum.html","page":"Quantum","title":"Quantum","text":"Socket\nsocket(::Quantum)\nScalar\nState\nOperator","category":"page"},{"location":"quantum.html#Qrochet.socket-Tuple{Quantum}","page":"Quantum","title":"Qrochet.socket","text":"socket(q::Quantum)\n\nReturns the socket of a Quantum Tensor Network; i.e. whether it is a Scalar, State or Operator.\n\n\n\n\n\n","category":"method"},{"location":"quantum.html#Qrochet.Scalar","page":"Quantum","title":"Qrochet.Scalar","text":"Scalar <: Socket\n\nSocket representing a scalar; i.e. a Tensor Network with no open sites.\n\n\n\n\n\n","category":"type"},{"location":"quantum.html#Qrochet.State","page":"Quantum","title":"Qrochet.State","text":"State <: Socket\n\nSocket representing a state; i.e. a Tensor Network with only input sites (or only output sites if dual = true).\n\n\n\n\n\n","category":"type"},{"location":"quantum.html#Qrochet.Operator","page":"Quantum","title":"Qrochet.Operator","text":"Operator <: Socket\n\nSocket representing an operator; i.e. a Tensor Network with both input and output sites.\n\n\n\n\n\n","category":"type"},{"location":"quantum.html","page":"Quantum","title":"Quantum","text":"Base.merge(::Quantum, ::Quantum...)","category":"page"},{"location":"quantum.html#Base.merge-Tuple{Quantum, Vararg{Quantum}}","page":"Quantum","title":"Base.merge","text":"merge(a::Quantum, b::Quantum...)\n\nMerges multiple Quantum Tensor Networks into a single one by connecting input/output sites.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Qrochet.jl","page":"Home","title":"Qrochet.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"info: BSC-Quantic's Registry\nQrochet, Tenet and some of its dependencies are located in our own Julia registry. In order to download Qrochet, add our registry to your Julia installation by using the Pkg mode in a REPL session,using Pkg\npkg\"registry add https://github.com/bsc-quantic/Registry\"","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Qrochet is a Quantum Tensor Networks library on top of Tenet.","category":"page"}]
}
